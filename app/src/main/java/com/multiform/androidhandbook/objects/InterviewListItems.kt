package com.multiform.androidhandbook.objects

import com.multiform.androidhandbook.R
import com.multiform.androidhandbook.models.ListArticleItem
import com.multiform.androidhandbook.models.MainListItem

object InterviewListItems {

    private val trainingList = mutableListOf(
        ListArticleItem("Время", R.drawable.ic_app_components, false,
            "Сколько надо времени на подготовку? Мой ответ: 1–2 месяца, в зависимости от свободного времени. Этого вполне достаточно. Ну, конечно же, если вы не метите в Гугл) Тогда сроки однозначно увеличиваются."),
        ListArticleItem("Портфолио", R.drawable.ic_app_components, false,
            "Надо ли иметь хорошее «портфолио»? Да!… Конечно же можно и без хорошего аккаунта на GitHub, например,… но меня мои pet-projects не раз спасали от скучных тестовых заданий! И, к тому же, Вы быстрее попадете на техническое собеседование."),
        ListArticleItem("Вопросы", R.drawable.ic_app_components, false,
            "Итак, Вы готовы приступить к подготовке… Что дальше? Составьте список вопросов, которые уже задавали другим Android разработчикам (в данном случае просто смотрите вопросы в списках ниже). И обязательно внимательно посмотрите требования к «интересным» вакансиям! Если там есть «Custom View», то обязательно вызубрите этапы создания этих несчастных вьюх! Спросят 100%!"),
        ListArticleItem("Теория", R.drawable.ic_app_components, false,
            "Дальше…Берёте небольшой блокнонт (размер не больше вашей ладони — просто удобно носить с собой) и пишите: Вопрос («Что такое Observable?») из списка подготовленных (см. пункт 3) и ниже Ответ (Это асинхронный паттерн проектирования, в котором данные представлены в виде потока событий….и так далее). Пишите от руки! Поверьте, это очень важно! \n" +
                    "Теперь у Вас есть готовый блоконот с основными вопросами и ответами…едем дальше…Встали с утра, собрались, поехали на метро… открываем блоконт и читаем, читаем, читаем… также едем обратно… читаем, читаем, читаем…\n" +
                    "Просто читаем? Нет! Прочитали вопрос…прикрыли блокнот и своими словами пытаемся сами себе рассказать… Забыли? Снова открываем блокнот, читаем ответ, закрываем, отвечаем и так далее пока не запомнили.\n" +
                    "Вот вы прочитали вопрос, рассказали самому себе ответ и вроде бы всё хорошо…Анализируйте! Прокрутите в голове свой ответ. Найдите термины, информацию, которая подтолкнет вашего «экзаменатора» на новые вопросы. И обязательно выпишите ответы на них!"),
        ListArticleItem("Практика", R.drawable.ic_app_components, false,
            "Для начала открываем наш список вопросов, и пробуем реализовать на практике каждый из них. Желательно еще и создать несколько небольших приложений которые будут использовать инструменты из наших вопросов."),
        ListArticleItem("Soft-скилы", R.drawable.ic_app_components, false),
        ListArticleItem("Вопросы для вас", R.drawable.ic_app_components, false),
        ListArticleItem("Что делать/не делать", R.drawable.ic_app_components, false,
            "Забегая вперед, скажу, после собеседования (или даже, прямо, во время) записывайте вопросы, на которые не ответили. Пишите в копилочку-блокнот и позднее обязательно письменно отвечайте. Пополняем базу знаний)"),
        ListArticleItem("Итоги", R.drawable.ic_app_components, false)
    )

    private val androidSdkList = mutableListOf(
        ListArticleItem("Android manifest", R.drawable.ic_app_components, false,
            "AndroidManifest - главный конфигурационный файл любого андроид приложения. Да и в принципе главный файл.\n" +
                    "В манифесте в главном теге <application> можно определить 4 основных компонента приложения. Activity, Service, BroadcastReceiver и ContentProvider."),
        ListArticleItem("Save activity state", R.drawable.ic_app_components, false,
            "onSaveInstanceState() - метод в котором мы можем сохранить данные активности при рестарте (например, повороте экрана) в пределах одного запуска приложения. Данные нужно предавать до вызова супер метода.\n" +
                    "onRestoreInstanceState() - метод в котором мы можем достать данные из state, помимо onCreate(). Разница в том, что этот метод вызывается после метода onStart(). Обязательно нужно проверить что Бандл не нулл перед восстановлением данных. Он = нулл при запуске приложения."),
        ListArticleItem("Launch Modes", R.drawable.ic_app_components, false,
            "Task - это отдельный процесс в системе, который создается когда мы хотим сделать действие, запустить новую задачу, например, запустить приложение.\n" +
                    "Backstack - это хранилище Activities внутри Task, где упорядочиваются наши активити с помощью типа хранения данных \"стэк\".\n" +
                    "Launch Modes - это инструкции по запуску активностей, позволяющие указать нужно ли создавать новую активность или использовать уже существующую и др. Этот атрибут указывается в манифсте у <activity>.\n" +
                    "Существует 4 режима LaunchMode:\n " +
                    "\"standart\" - поведение Activity, установленного в этот режим, будет всегда создавать новую Activity, чтобы работать отдельно с каждым отправленным Intent.\n" +
                    "\"singleTop\" - режим ведет себя почти так же, как и standard. Отличие состоит в том, что если уже есть экземпляр Activity с таким же типом наверху стека, не будет создано никакого нового Activity, вместо этого Intent будет отправлен существующему экземпляру Activity через метод onNewIntent().\n" +
                    "\"singleTask\" - Activity разрешено иметь только один экземпляр в системе. Если в системе уже существует такой Activity, Task, удерживающий экземпляр, будет перемещен наверх, а Intent будет предоставлен через метод onNewIntent(). В противном случае будет создано новое Activity и помещено в новый Task.\n" +
                    "\"singleInstance\" - Task в этом режиме может иметь только одно Activity — то, у которого атрибут singleInstance. Если из этого Activity вызывается другое Activity, автоматически создается новый Task для размещения этого нового Activity.\n" +
                    "Работают они в связке с Intent-флагами, котрые поступают из Intent-объекта."),
        ListArticleItem("taskAffinity", R.drawable.ic_app_components, false,
            "Этот атрибут <activity> указывает к какой задаче(Task) привязаны действия в данной активити. Пустое заначение \"\" будет означать, что действия не привязаны ни к какой задаче."),
        ListArticleItem("Intent flags", R.drawable.ic_app_components, false,
            "Помимо LaunchMode мы так же можем конфигурировать поведение активити с помощью Интент-флагов, указывая их в методе addFlags() нового Intent. Это инструкция параметр с помощью которой можно указать поведение активности в системе.\n" +
                    "Один из самых популярных флагов FLAG_ACTIVITY_CLEAR_TOP. Если указать этот флаг при вызове активности, то активность с этим флагом, которая жива в задаче, не будет пересоздаваться при ее повторном вызове. Если поверх нее в стэке есть другие активности, то они будут очищены из стэка, а активность с флагом будет наверху."),
        ListArticleItem("Виды Intent", R.drawable.ic_app_components, false,
            "Intent (намерение) - это объект обмена сообщениями, с помощью которого можно запросить выполнение действия у компонента вашего или другого приложения.\n" +
                    "Обычно интент используется в 3 сценариях:\n" +
                    "1. Для запуска операции (Activity): объект Intent описывает операцию, которую требуется запустить, а также содержит все остальные необходимые данные. Для этого мы запускаем новую Activity с помощью метода startActivity() и передаем интент. Если после завершения операции от нее требуется получить результат, вызываем метод startActivityForResult(). А результат получаем в виде отдельного объекта Intent в методе onActivityResult() исходного активити.\n" +
                    "2. Для запуска сервиса (Service): сервис можно запустить, передав объект Intent методу startService(). Service является компонентом, который выполняет действия в фоновом режиме без пользовательского интерфейса. Объект Intent описывает службу, которую требуется запустить, а также содержит все остальные необходимые данные. Также можно установить привязку к другму уже запущенному сервису, передав объект Intent методу bindService().\n" +
                    "3. Для рассылки широковещательных сообщений (Broadcast Receiver): компонент, который может получать события (events) от системы или от других приложений. Например, что девайс загрузился, или что был включен режим полета или что сменился язык системы и другое. Так же можно получить из приложения. Например, что файл скачался из сети, или что нужно почистить БД.\n" +
                    "Существует 2 типа объекта интент. \n" +
                    "1. Explicit (явный) объект Intent - запускает действие (сервис, приемник) в определенном активити вашего приложения, которое указывается по имени при создании интента.\n" +
                    "2. Implicit (неявный) объект Intent - запускает действие в неопределенном активити, которое определяется системой по флагам, которые вы указываете при создании. Обязательно указывается тип данных которые мы хотим передать.\n" +
                    "При вызове неявного интента юзер френдли будет проверить есть ли в системе приложение которое может обработать интент. Сделать это можно так:\n" +
                    "if (intent.resolveActivity(getPackageManager()) != null) {\n" +
                    "\tstartActivity(intent)\n" +
                    "}\n" +
                    "Параметры интента:\n" +
                    "Component name - обязательное поле при создании явного интента. В нем нужно указать имя активности в которую вы хотите запустить.\n" +
                    "Action - поле в котором вы указываете какое действие вы хотите выполнить с помощью интента. Обязательно для неявных интент.\n" +
                    "Поля для передачи информации:\n" +
                    "Data - в этом поле указывается URI путь к файлу,который вы хотите передать. Также обязательно указывать тип файлов открываемых приложением.\n" +
                    "Extras - поле для хранения и передачи информации в интенте с помощью ключ-значение. Можно передать примитивный тип, либо целый объект с помощью сериализации. Также можно записать данные в Bundle() и затем передать его в интент.\n" +
                    "Указание флага:\n" +
                    "Category - параметр указывающий категорию приложения в котором будет открыта активность и выполнен интент.\n" +
                    "Flags - это инструкция параметр с помщью которой можно указать поведение активности в системе.\n" +
                    "Один из самых популярных флагов FLAG_ACTIVITY_CLEAR_TOP. Если указать этот флаг при вызове активности, то активность с этим флагом, которая жива в задаче, не будет пересоздаваться при ее повторном вызове. Если поверх нее в стэке есть другие активности, то они будут очищены из стэка, а активность с флагом будет наверху.\n" +
                    "<intent-filter> - определяют тип интентов которые должны получить компоненты вашего \\ другого приложения. Определяются они в манифесте."),
        ListArticleItem("Service", R.drawable.ic_app_components, false,
            "Service - это background компонент, который совершает операции в фоне без UI. Сервисы способны выполнять операции даже при закрытом вызывающем приложении.\n" +
                    "Сервисы делятся на 2 типа:\n" +
                    "Foreground - видимые сервисы, которые оповещают пользовательля о своей работе. Чаще всего такой тип сервиса имеет нотификацию. Например, проигрывание музыки в спотифай отображается на панели уведомлений.\n" +
                    "Background - невидимые для юзера сервисы, которые работают без оповещений в фоне системы.\n" +
                    "ВНИМАНИЕ! С версии 26+ бэк сервисы нельзя запускать если приложение не в форэграунд. Чтобы быть юзер френдли лучше делать все сервисы фореграунд типа, с нотификацией.\n" +
                    "Сервисы декларируются в манифесте. Существует 3 важных поля у сервисов:\n" +
                    "1. android:name=\".SuperService\" - имя сервиса, по которому ему можно будет идентифицировать.\n" +
                    "2. android:description=\"Description...\" - описание сервиса. Чтобы пользователь всегда знал что и зачем у него запущено. Описание будет отображаться в списке действующих сервисов.\n" +
                    "3. android:exported=[\"true\"|\"false\"] - определяет можно ли заупскать сервис из других приложений.\n" +
                    "Service можно создать в коде. У сервиса есть 4 важных переопределяемых метода, которые по сути представляют его жизненный цикл.\n" +
                    "onCreate() - вызывается только ожин раз при создании сервиса.\n" +
                    "onStartCommand() - вызывается каждый раз когда сервису передается интент. В онСтартКоманд можно узнать и указать какое именно действие нужно совершить сервису.\n" +
                    "onBind() - метод позволяет присоеденится к уже существующему сервису, вместо того, чтобы создавать новый.\n" +
                    "onDestroy() - вызывается когда сервис заканчивает работу и умирает. Здесь мы закрываем все наши переменные.\n" +
                    "Вызвать сервис будет так:\n" +
                    "val intent = Intent(this, SuperService::class.java)\n" +
                    "startService(intent)\n" +
                    "После того как вы убедились что сервис отработал, нужно обязательно его остановить. Сделать можно так:\n" +
                    "stopService(intent) - внутри приложения.\n" +
                    "stopSelf() или stopSelf(startId) - внутри сервиса в методе onDestroy()"),
        ListArticleItem("IntentService", R.drawable.ic_app_components, false,
            "IntentService - работает как обычный сервис, за исключением того, что он работает в своем выделенном потоке, и умирает сразу же как только выполнит свою задачу. Этот тип сервиса всегда работает в background режиме. У него нет нотификации. При его создании не нужно вызывать методы onBind() - т.к. по умолчанию нулл, onDestroy() - это понятно, и onStartCommand() - так как он автоматом отправляет все интенты в рабочий поток, из которого они по одному приходят в onHandleIntent().\n" +
                    "У intentService есть все один метод который мы можем переопределить, это onHandleIntent(intent: Intent), где мы обрабатываем интенты."),
        ListArticleItem("Broadcast Receiver", R.drawable.ic_app_components, false,
            "BroadcastReceiver - компонент, который может получать события (events) от системы или от других приложений. Например, что девайс загрузился, или что был включен режим полета или что сменился язык системы и другое. Так же можно получить из приложения. Например, что файл скачался из сети, или что нужно почистить БД.\n" +
                    "Как работать с ресивером? Создаем слушатель событий от ресивера:\n" +
                    "val listener = object : BroadcastReceiver() {\n" +
                    "\t@Override\n" +
                    "\tfun onReceive(context: Context, intent: Intent) {\n" +
                    "\t\t//some event action\n" +
                    "\t}\n" +
                    "}\n" +
                    "ВНИМАНИЕ! Нельзя производить тяжелые длительные операции в слушателе с ресивером, иначе получим ANR.\n" +
                    "Receiver можно зарегистрировать в манифесте.\n" +
                    "Так же его можно зарегистрировать в коде. Но затем обязательно нужно закрыть его в onDestroy().\n" +
                    "Чтобы обезпечить безопасность приложения, нужно обязательно назначить параметр android:exported=\"false\", чтобы ресивером могли пользоваться только вы из внутри вашего приложения. Значение \"true\" нужно только в том случае если вы пишите ресивер которым могут воспользоваться другие приложения."),
        ListArticleItem("ContentProvider", R.drawable.ic_app_components, false,
            "Контент-провайдер или \"Поставщик содержимого\" (Content Provider) - это оболочка (wrapper), в которую заключены данные. Если ваше приложение использует базу данных SQLite, то только ваше приложение имеет к ней доступ. Но бывают ситуации, когда данные желательно сделать общими. Простой пример - ваши контакты из телефонной книги тоже содержатся в базе данных, но вы хотите иметь доступ к данным, чтобы ваше приложение тоже могло выводить список контактов. Так как вы не имеете доступа к базе данных другого приложения, был придуман специальный механизм, позволяющий безопасно получать доступ и делиться своими данными c другими приложениями. \n" +
                    "Поставщики контента предлагают детальный контроль над разрешениями на доступ к данным. Вы можете ограничить доступ к поставщику контента исключительно из вашего приложения, предоставить полное разрешение на доступ к данным из других приложений или настроить различные разрешения для чтения и записи данных."),
        ListArticleItem("ViewGroup", R.drawable.ic_app_components, false,
            "View - это базовый строительный блок для компонентов пользовательского интерфейса. От этого класса наследуются все другие виджеты и UI компоненты.\n" +
                    "ViewGroup - это специальный контейнер который может содержать в себе другие View. Это базовый класс для layouts и containers, таких как LeanerLayout, ConstraintLayout и т.д.\n" +
                    "ViewGroup имеет вложенный класс LayoutParams. Каждый дочерний класс ViewGroup наследует этот вложенный класс. В этом классе есть параметры которые определяют размер и положение каждого дочернего View. LayoutParams имеет отдельные параметры для каждого дочернего класса. Нельзя обращаться к параметрам из layout к которым они не относятся, чтобы не получить крэш."),
        ListArticleItem("Layout containers", R.drawable.ic_app_components, false,
            "FrameLayout - это View контейнер, который отображает элементы в виде стэка. Они могут наслаиваться друг на друга. В основном положение элементов регулируется свойством gravity.\n" +
                    "LeanerLayout - контейнер, который может отображать элементы вертикально либо горизонтально. Элементы не накладываются друг на друга. За выравнивание элементов отвечает свойство layout_gravity. Также элементам можно указать параметр вес(layout_weight), чтобы указать как контейнер делит пространство между элементами. Параметр weightSum определяет общий вес элементов чтобы задать процентное соотношение. Если его не указать, вес посчитается автоматически.\n" +
                    "TableLayout - подходит для верстки таблиц, расписаний.\n" +
                    "RelativeLayout - контейнер, в котором элементы могут быть расположены по отношению друг к другу либо к родителю. Свойство alineParent... - выравнивает элементы относительно родителя. А свойства below и above располагают элемент после и перед указанным, соответственно. ВНИМАНИЕ! Доки рекомендуют использовать вместо RelativeLayout - ConstraintLayout из-за проблем первого с производительностью.\n" +
                    "ConstraintLayout - контейнер, который реализует концепцию привязки элементов друг к другу либо к родителю. У каждого элемента вы указываете с какой стороны элемента к какой стороне другого элемента вы хотите сделать привязку.\n" +
                    "Решение проблем иерархии и производительности представлений:\n" +
                    "1. Удаление избыточных вложенных макетов.\n" +
                    "2. Удаление лишних вбюх, использование меньшего их количества.\n" +
                    "3. Использование более легковесных вьюх и контейнеров.\n" +
                    "4. Использовать тэги marge / include.\n" +
                    "ДОП!!! Как андроид рисует представления и макеты? Отрисовка происходит в 3 фазы:\n" +
                    "Measure - сначала система определет рзмеры родителей и потомков(вьюх). Происходит рекурсивный обход дерева вьюх и каждая вью передает требования к размерам и положению к своим потомкам.\n" +
                    "Layout - происходит рекурсивный обход дерева вьюх сверху вниз и каждый родитель размещает своих потомков в соответствии с данными полученными из предыдущего этапа. Происходит позиционирование.\n" +
                    "Draw - рисует вью на экране на основе предыдущих данных."),
        ListArticleItem("Notification", R.drawable.ic_app_components, false,
            "Notification - это уведомление, которое приложение показывет поверх всех экранов. А так же оно отображается в панели уведомлений пока пользователь не закроет его.\n" +
                    "Notifications могут быть dismissable or not dismissable, тоесь свайпаются или не свайпаются для закрытия.\n" +
                    "Они могут содержать кнопки.\n" +
                    "Также они сами могут быть кликабельны, что, обычно, запускает приложение на передний план (foreground).\n" +
                    "Нотификации могут отображаться на экране блокировки.\n" +
                    "Notification создаются через Builder():\n" +
                    "val notif = NotificationCompat.Builder(this, CHANNEL_ID)\n" +
                    "туда передается контекст и id канала.\n" +
                    "Метод setAutoCancel(boolean) - указывает dismissable.\n" +
                    "Так же в нотификацию можно передать иконку, заголовок и текст.\n" +
                    "В методе setDefaults() - можно передать атрибуты указывающие как уведомление будет оповещать пользователя о себе. Например, звук, вибрация, цветовой индикатор.\n" +
                    "Метод setImportance() выставляет приоритет уведомления, который влияет на порядок отображения, на способ оповещения и т.д.\n" +
                    "Завершаем создание нотификации методом build()\n" +
                    "Чтобы показать уведомление нужно использовать NotificationManager:\n" +
                    "val manager = getSystemService(Context.NOTIFICATION_SERVICE)\n" +
                    "manager.notify(NOTIFICATION_ID, notif)\n" +
                    "Чтобы показать уведомление с действием (по кнопке или onClick) нам понадобится Intent. Для нотификации нам нужен PendingIntent. Он содержит в себе действие:\n" +
                    "val actionIntent = Intent(this, MainActivity::class.java) //нужное нам действие\n" +
                    "val pendingIntent = PendingIntent.getActivity(this, INTENT_ID, actionIntent, PendingIntent.FLAG_...)\n" +
                    "Последний атрибут содержит флаг, который указывает создавать ли новый pendingIntent или нет.\n" +
                    "Передаем наш pendingIntent в Билдер с помощью метода setContentIntent(pendingIntent) до метода build(), естественно.\n" +
                    "Чтобы добавить кнопки в уведомление используем метод addAction(<some pendingIntent>). Не рекомендуется больше 3 кнопок.\n" +
                    "С версии 8.1 звук у уведомлений может звучать не более раза в секунду.\n" +
                    "Начиная с версии 8.0 нотификации не работают без привязки их к каналам. (Переходим к NotificationChannel)"),
        ListArticleItem("Notification channels", R.drawable.ic_app_components, false,
            "Идея создания каналов была в том, чтобы предоставить юзерам больше возможностей для управления уведомлениями. Чтобы юзер мог отключить уведомления либо всему приложению, либо отдельным категориям уведомлений. А так же настраивать отдельные категории уведомлений по разному.\n" +
                    "Чтобы создать канал нотификаций нужно, для начала, проверить версию андроид выше 8.0:\n" +
                    "if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n" +
                    "val channel = NotificationChannel(CHANNEL_ID, NAME, NotificationManager.IMPORTANCE_DEF)\n" +
                    "В методе channel.setDescription(CHANNEL_DESC) задаем описание каналу.\n" +
                    "Далее создаем NotificationManager (если уже не создали на пред. этапе) и передаем ему channel в методе createNotifChannel().\n"),
        ListArticleItem("Toast & SnackBar", R.drawable.ic_app_components, false,
            "Toast - это небольшое вспывающее сообщение на экране.\n" +
                    "Тост оторажается на экране ограничное количесво времени. Есть короткий и длнный тост. Примерно 2, 4 сек соответственно. В тост не следует передавать длинные сообщения, т.к. пользователь скорее всего не успеет его прочитать.\n" +
                    "Для Тост можно создать свой лайаут. Тогда го следует создавать через конструктор класса, передавая контекст. Затем настраиваются свойства. Гравити, сетВью, Дюрэйшн.\n" +
                    "SnackBar - это тоже небольшое всплывающее сообщение (обычно снизу), которое обычно рекомендуется использовать в том же экране где произошло действие.\n" +
                    "СнэкБар может иметь кнопки а так же он может сдвигать содержимое экрана освобождая место для себя. СнекБар, в отличае от тост, может быть бесконечно отображен, пока пользователь его не закроет или не нажмет на кнопку. Добавить кнопку можно с помощью метода setAction()."),
        ListArticleItem("ProgressBar", R.drawable.ic_app_components, false,
            "ProgressBar - это UI элемент, который отображает прогресс завершения какой-либо операции. Например, загрузка приложения, ожидание подгрузки формы или сохранение данных в сети.\n" +
                    "ПрогресБар делится на две модели отображения прогресса:\n" +
                    "Determinate (детерминированный) - модель, которая отображает постепенный конечный прогресс.\n" +
                    "Indeterminate (недетерминированный) - модель, которая отображает прогресс в виде бесконечной загрузки. Он используется когда вы не знаете сколько времени займет операция.\n" +
                    "Тип модели можно указать в XML определении бара. По умолчанию он недетерминированный."),
        ListArticleItem("PendingIntent", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("Threads", R.drawable.ic_app_components, false,
            "Main (UI) поток - это основной поток приложения. В нем запускается главное активити приложения и отрабатывает основной интерфейс приложения.\n " +
                    "Все методы жизненного цикла активити вызываются в главном потоке.\n" +
                    "При запуске длительной операции (более 5 сек) в главном потоке мы получим ошибку ANR(Application Not Responsive), в результате которой система предложит убить наше приложение.\n" +
                    "Все длительные операции нужно вызывать в background потоке.\n" +
                    "Чтобы запостить данные в из БГ потока в UI поток, можно использовать методы View.post(), runOnUiThread {}, Handler.post()."),
        ListArticleItem("Handler, Looper, MessageQueue", R.drawable.ic_app_components, false,
            "Приложения в Android запускаются в виртуальной машине, использующей Java Runtime. В Java вся работа выполняется в потоках. Поток заканчивает работу, когда отрабатывает метод run(). В Android главный (UI) поток не всегда занят выполнением какой-либо задачи и часто находится в ожидании действий пользователя или событий системы. Для реализации такого поведения в Android используются три сущности, которые работают вместе: Looper, MessageQueue и Handler.\n" +
                    "Looper запускает цикл обработки сообщений, связанный с потоком. Поток работает, пока связанный с ним лупер не будет остановлен. Важным характером Looper является то, что он связан с потоком, в котором создается Looper. Эта связь хранится вечно и не может быть нарушена или изменена. Также, поток не может быть связан с более чем одним Looper.\n" +
                    "Для создания лупера, вызывается статический метод Looper.prepare(). Созданный лупер будет связан с потоком, в котором вызван этот метод. Для старта лупера используется статический метод Looper.loop(). Между вызовами методов prepare() и loop() обычно создается Handler, который будет обрабатывать сообщения, приходящие в MessageQueue лупера. Для остановки лупера используется метод quit() или quitSafely(). Разница между этими методами в том, что quit() останавливает лупер незамедлительно, а quitSafely() завершает обработку сообщений, которые уже добавлены в очередь. Эти методы не статические и вызываются на инстансе класса Looper. Получить лупер текущего потока можно статическим методом Looper.myLooper(). Лупер UI потока можно получить методом Looper.getMainLooper().\n" +
                    "Handler – это класс, который используется для работы с очередью сообщений, связанной с потоком. Хэндлер позволяет отправлять сообщения в другие потоки с задержкой или без, а также обрабатывать полученные сообщения. Хэндлер всегда связан с лупером, который в свою очередь связан с каким-либо потоком. В отличие от Looper, несколько экземпляров Handler могут быть привязаны к одному и тому же потоку. При создании хэндлера в конструктор можно передать объект Looper. Если используется дефолтный конструктор, то хэндлер создается на текущем потоке. Если с потоком не связан лупер, то при создании хэндлера бросается RuntimeException.\n" +
                    "Методы post*() используются для шедулинга объектов Runnable, которые выполняются на связанном с хэндлером потоке. Объекты Runnable добавляются в очередь сообщений. Метод post(action: Runnable) добавляет объект action в конец очереди без специального условия по времени, т.е. action будет запущен, как только это будет возможно. Методы postAtTime() и postDelayed() принимают параметром конфигурацию времени (точное время и задержку относительно текущего времени соответственно). На скриншоте пример шедулинга действия на UI потоке. Класс Handler имеет методы send*(), аналогичные методам post*(), но для шедулинга объектов Message, которые позволяют передать произвольный объект.\n" +
                    "MessageQueue - это класс с помощью которого реализована очередь сообщений, с которыми работают Handler и Looper. MessageQueue не имеет публичных методов для работы с сообщениями. Работа с очередью выполняется через методы класса Handler. MessageQueue хранит объекты класса Message.\n" +
                    "В объекте message можно передать Bundle, который добавляется и получается методами setData() и getData(). Помимо data-bundle в message есть два публичных поля типа int: arg1 и arg2, а также публичное поле obj типа Object. Эти поля используются в тех случаях, когда нужно передать целочисленное значение или произвольный объект, и нет необходимости создавать bundle. Также класс Message имеет публичное целочисленное поле what, которое по смыслу подобно параметру requestCode в методе startActivityForResult() и используется для определения о чем это сообщение. Класс Message имеет публичный конструктор, но вместо него рекомендуется использовать статические методы Message.obtain() или Handler.obtainMessage(). Методы obtain возвращают message из пула объектов. После обработки сообщения нужно вызвать метод Message.recycler(), для освобождения связанных ресурсов и возвращения объекта message в пул. Помимо объектов с данными в message можно задать callback типа Runnable, который будет вызван хэндлером после обработки сообщения. Для этого сообщение создается методом Message.obtain(handler: Handler, callback: Runnable)."),
        ListArticleItem("Планировщики задач", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("Serializable / Parcelable", R.drawable.ic_app_components, false,
            "Сериализация (Serialization) — это процесс, который переводит объект в последовательность байтов, по которой затем его можно полностью восстановить. При обычном выполнении программы срок жизни любого объекта — от запуска программы до ее окончания. Сериализация позволяет существовать объекту между запусками программы. Сериализация нужна для межпроцессорного взаимодействия.\n" +
                    "Serializable - это интерфейс, не имеющий методов, который указывает jvm, что объекты этого класса могут быть сериализованы. Так как механизм сериализации связан с базовой системой ввода/вывода и переводит объект в поток байтов, для его выполнения необходимо создать выходной поток OutputStream, упаковать его в ObjectOutputStream и вызвать метод writeObject(). Для восстановления объекта нужно упаковать InputStream в ObjectInputStream и вызвать метод readObject().\n" +
                    "Parcelable - это интерфейс для классов, экземпляры которых могут быть записаны и восстановлены из класса Parcel. Если класс реализует интерфейс Parcelable, поля класса сериализуются в методе writeToParcel().\n" +
                    "Также parcelable класс обязан иметь статическое ненулевое поле, названное CREATOR типа Creator<T>. Интерфейс Creator<T> имеет два метода createFromParcel(parcel: Parcel): T и newArray(size: Int): Array<T>. Эти методы обратные writeToParcel() и используются для чтения данных из Parcel и создания объекта. Объект Parcelable записывается в контейнер Parcel, который имеет метод marshall(): Array<Byte> для представления объекта в виде массива байтов.\n" +
                    "При изменении структуры объекта или реализации метода writeToParcel() байтовое представление, которое возвращается методом marshall(), будет изменено. Поэтому строго не рекомендуется записывать его в персистентное хранилище.\n" +
                    "Существует расхожее мнение, что Serializable медленнее, чем Parcelable. Serializable использует рефлекшн и создает много дополнительных объектов, а в Parcelable разработчик сам указывает какие объекты сериализовать. Исходя из этого умозаключения, рекомендуется всегда использовать Parcelable.\n" +
                    "Но на самом деле такое сравнение Serializable и Parcelable не совсем честное. Дело в том, что в Serializable тоже есть режим «ручного управления». Чтобы не использовать рефлекшн и задать сериализуемые поля вручную, нужно использовать методы writeObject() и readObject() в serializable-классе. В этом случае Serializable работает быстрее, чем Parcelable."),
        ListArticleItem("addOnBackStackChangeListener", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("Dialog / DialogFragment", R.drawable.ic_app_components, false,
            "Dialog - это небольшое окно, в котором пользователю предлагается принять решение или ввести дополнительную информацию. Диалоговое окно не заполняет экран и обычно используется для модальных событий, которые требуют, чтобы пользователи совершили действие, прежде чем продолжить.\n" +
                    "Для создания Диалога следует использовать один из следующих классов:\n" +
                    "AlertDialog - диалоговое окно, которое может отображать заголовок, до трех кнопок, список выбираемых элементов или настраиваемый макет.\n" +
                    "DatePickerDialog или TimePickerDialog - диалог с предопределенным пользовательским интерфейсом, который позволяет пользователю выбрать дату или время.\n" +
                    "Вы должны использовать DialogFragment в качестве контейнера для вашего диалога. Класс DialogFragment предоставляет все элементы управления, необходимые для создания вашего диалога и управления его внешним видом.\n" +
                    "Использование DialogFragment для управления диалоговым окном гарантирует, что оно правильно обрабатывает события жизненного цикла, например, когда пользователь нажимает кнопку «назад» или поворачивает экран. DialogFragment также позволяет повторно использовать пользовательский интерфейс в диалоговом окне в качестве встраиваемого компонента в большей UI, так же, как традиционные Fragment.\n" +
                    "Существует также ProgressDialog, но доки не рекомендуют(запрещают) его использовать. Такой диалог полностью блокирует интерфейс на время загрузки, что раздражает пользователей. Намного лучше создавать погресс анимации для конкретных вью на время згрузки."),
        ListArticleItem("Clean architecture", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("MVC, MVP, MVVM, MVI", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("MVP / MVVM - отличия", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("Dagger 2", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("Doze Mode", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("LiveData", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("ViewModel", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("Room / Moxy / Realm", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("invalidate() in view", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("ValueAnimator / ObjectAnimator", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("Paging library", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("Zygote", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("Bundle", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("Spannable", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("context activity / application context", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("setRetainInstance in fragment", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    ""),
        ListArticleItem("AsyncTask", R.drawable.ic_app_components, false,
            "\n" +
                    "\n" +
                    "\n" +
                    "")
    )

    val interviewList = mutableListOf(
        MainListItem("Подготовка", R.drawable.ic_app_components, trainingList),
        MainListItem("Android SDK", R.drawable.ic_app_components, androidSdkList),
        MainListItem("RxJava & Coroutines", R.drawable.ic_app_components),
        MainListItem("Libraries", R.drawable.ic_app_components),
        MainListItem("Kotlin", R.drawable.ic_app_components),
        MainListItem("Java", R.drawable.ic_app_components),
        MainListItem("Общие вопросы", R.drawable.ic_app_components),
        MainListItem("Примеры задач", R.drawable.ic_app_components),
        MainListItem("Материалы для подготовки", R.drawable.ic_app_components)
    )
}